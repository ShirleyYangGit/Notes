# 中断
CPU在中断向量表，查找处理例程。找到不同中断需要调度哪个程序来处理。

## 硬中断

## 软中断
用户程序**系统调用**过程：
1. app发出0x80中断（或调用sysenter原语，新系统中，硬件支持快速切换到内核态）
2. os进入内核态
3. 在中断向量表中查找处理例程
4. 保存硬件现场CS IP等寄存器值
5. 保存app现场 堆栈与寄存器的值
6. 执行中断例程system call
   - 根据参数与编号寻找对应例程
   - 执行并返回
7. 恢复现场
8. 返回用户态
9. app继续执行


# 内核态和用户态
CPU - CPL指令级别 -> 0 1 2 3
不同的指令可以跑在不同的级别上。级别比较高的，可以直接访问硬件。比较危险的指令只能比较高的级别才能跑。

Linux操作系统中用了两个级别。
- 内核态 0 - Linux 内核
内存中，有专门的内核空间。内核态可以访问内核空间和用户空间
- 用户态 3 - 用户程序
用户态只能访问用户空间，不能访问内核空间。

# 面试例子
## 线程
一个程序里不同的执行路径。
## 纤程
即协程。轻量级的线程，可以启10000个。
## 为什么纤程比线程效率高
纤程运行在用户态，不用和内核态打交道。
启动线程，需要和通过system call（软中断，80中断），由用户态转到内核态，由操作系统来启线程。
启动纤程，不需要调用system call，处理异步编程的。
## 为什么和内核态打交道效率低
看软中断，用户程序系统调用过程，比较浪费资源

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTk5NTEwNjg5MCwtMTc0MzA0MzQ3MSwtMT
cxNDExNzI3Ml19
-->