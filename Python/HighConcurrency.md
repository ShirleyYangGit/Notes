# 如何处理大量并发请求

当有多个请求同时需要处理的时候，我们的第一反应是为每个请求创建一个线程或进程来处理。这种我们成为同步阻塞方式。在C10K以前，Linux中网络处理都用同步阻塞方式。在请求数100个时，这种方式自然没问题，但增加到10000个请求时，10000个进程或线程的调度、上下文切换乃至它们占用的内存，都会成为瓶颈。
既然每个请求分配一个线程方式不合适，那么为了支持10000个并发请求，这里有两个问题需要我们解决：
第一，怎样在一个线程内处理多个请求，也就是要在一个线程内响应多个网络I/O。以前的同步阻塞方式下，一个线程只能处理一个请求，到这里不再适用，是不是可以用非阻塞I/O或者异步I/O来处理多个网络请求呢？
第二，怎么更节省资源地处理客户请求，也就是要用更少的线程来服务这些请求。是不是可以继续用原来的100个或者更少的线程，来服务现在的10000个请求呢？
# C10K and C1000K

## I/O模型优化
异步、非阻塞I/O的解决思路，其实就是我们在网络编程中经常用到的I/O多路复用（I/O Multiplexing）。
### 非阻塞I/O和水平触发通知，比如使用select或者poll
### 非阻塞I/O和边缘触发通知，比如epoll

### 使用异步I/O (Asynchronous I/O, 简称AIO)
## 工作模型优化
### 主进程 + 多个worker子进程

### 监听到相同端口的多进程模型

## C10M
最大请求量可以无限增多。特别是当升级完硬件（比如足够多的内存、带宽足够大的网卡、更多的网络功能卸载等）后，你可能会发现无论怎么优化应用程序和内核中的各种网络参数，想实现1000万的请求的并发，都极其困难。
究其根本，还是Linux内核协议栈做了太多太繁重的工作。从网卡中断带来的ying zh
# Python 协程




<!--stackedit_data:
eyJoaXN0b3J5IjpbLTc4ODgzMjcwMCwtNzcyNTg1ODQ4XX0=
-->